// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
var Verifier = artifacts.require('Verifier');
const truffleAssert = require('truffle-assertions');
const proof_json = require('../../zokrates/code/square/proof.json');

// - use the contents from proof.json generated from zokrates steps
const proofData = {
  proof: {
    A: [
      web3.utils.toBN(proof_json.proof.a[0]).toString(),
      web3.utils.toBN(proof_json.proof.a[1]).toString(),
    ],
    B: [
      [
        web3.utils.toBN(proof_json.proof.b[0][0]).toString(),
        web3.utils.toBN(proof_json.proof.b[0][1]).toString(),
      ],
      [
        web3.utils.toBN(proof_json.proof.b[1][0]).toString(),
        web3.utils.toBN(proof_json.proof.b[1][1]).toString(),
      ],
    ],
    C: [
      web3.utils.toBN(proof_json.proof.c[0]).toString(),
      web3.utils.toBN(proof_json.proof.c[1]).toString(),
    ],
  },
  input: proof_json.inputs,
};

contract('Verifier', (accounts) => {
  before(async () => {
    this.verifier = await Verifier.new({ from: accounts[0] });
  });

  // Test verification with correct proof
  it('should verify with correct proof', async () => {
    let isVerified = await this.verifier.verifyTx(
      proofData.proof.A,
      proofData.proof.B,
      proofData.proof.C,
      proofData.input,
      { from: accounts[0] }
    );
    assert.equal(isVerified, true);
  });

  // Test verification with incorrect proof
  it('should not verify with incorrect proof', async () => {
    let isVerified = await this.verifier.verifyTx.call(
      proofData.proof.A,
      proofData.proof.B,
      proofData.proof.C,
      [18, 2], //  proofData.input  ->  "input":[9,1]
      { from: accounts[0] }
    );
    assert.equal(isVerified, false);
  });
});
